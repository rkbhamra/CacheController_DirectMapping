# CacheController_DirectMapping

A direct-mapping cache controller has a relatively simple functioning. It starts with taking a memory address from the CPU, splitting it by bits into TAG, INDEX & OFFSET. The cache controller has an Address Word Register (AWR) within itself that stores the TAG, valid-bit & dirty-bit values for each of the 8 blocks in the cache. The controller compares the new CPU TAG with the TAG at the index INDEX in the AWR. If the tag-compare is successful, it checks for valid-bit at INDEX in AWR. If the v-bit is 1, it is a hit and the data is read back to CPU; or if the CPU wants to write to the memory, CPU data is written to the address INDEX&OFFSET in the cache and d-bit is set to 1. Now, if in a subsequent operation, the CPU requests to read from an address and it is not found in cache; i.e.; tag-compare at the given INDEX is unsuccessful, the controller will first write back the block at INDEX to main memory. Then it will load from the memory the block at address TAG&COMPARE&’00000’ into a cache block with index INDEX, set d-bit to 0 and v-bit to 1. Then depending on what the CPU requested it will either read back the new data to the CPU or  it will write from CPU to the cache and set d-bit to 1.
